{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"AAAA,eAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0Bf,IAAA,AAAM,8BAAN;;aAAM;gCAAA;QAEJ,uBAAQ,gBAA4C,CAAC;;kBAFjD;;YAaJ,KAAA;mBAAA,SAAA,gBAAgB,MAAmC;gBACjD,IAAI,CAAC,YAAY,GAAG,mBAAK,IAAI,CAAC,YAAY,EAAK;YACjD;;;YAEA,KAAA;mBAAA,SAAA;gBACE,OAAO,IAAI,CAAC,YAAY;YAC1B;;;YAEA,KAAA;mBAAA,SAAA;gBACE,IAAI,CAAC,YAAY,GAAG,CAAC;YACvB;;;;YAjBO,KAAA;mBAAP,SAAO;gBACL,IAAI,CAPF,AAOG,cAAc,QAAQ,EAAE;oBAP3B,cAQc,QAAQ,GAAG,IARzB;gBASF;gBACA,OAVE,AAUK,cAAc,QAAQ;YAC/B;;;WAXI;;AACJ,iBADI,eACW,YAAf,KAAA;AAyBF,IAAA,AAAM,6BAAN;;aAAM;gCAAA;QACJ,uBAAQ,UAA2B;YACjC,KAAK;YACL,QAAQ;YACR,SAAS,CAAC;YACV,cAAc;YACd,YAAY;YACZ,YAAY;QACd;QAEA,uBAAQ,uBAA+C,EAAE;QACzD,uBAAQ,wBAAmD,EAAE;;kBAXzD;;YAaI,KAAA;mBAAR,SAAQ;gBACN,IAAM,eAAe,cAAc,WAAW,GAAG,eAAe;gBAChE,OAAO,wCACF,cACA,IAAI,CAAC,MAAM;oBACd,SAAS,mBACJ,yBAAA,mCAAA,aAAc,OAAO,EACrB,IAAI,CAAC,MAAM,CAAC,OAAO;;YAG5B;;;YAEA,KAAA;mBAAA,SAAA,sBAAsB,WAAkC;gBACtD,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC;gBAC9B,OAAO,IAAI;YACb;;;YAEA,KAAA;mBAAA,SAAA,uBAA0B,WAAmC;gBAC3D,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC;gBAC/B,OAAO,IAAI;YACb;;;YAEA,KAAA;mBAAA,SAAA,OAAO,GAAW;gBAChB,IAAI,CAAC,MAAM,CAAC,GAAG,GAAG;gBAClB,OAAO,IAAI;YACb;;;YAEA,KAAA;mBAAA,SAAA,UAAU,MAAkC;gBAC1C,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG;gBACrB,OAAO,IAAI;YACb;;;YAEA,KAAA;mBAAA,SAAA,WAAW,OAAoC;gBAC7C,IAAI,CAAC,MAAM,CAAC,OAAO,GAAG;gBACtB,OAAO,IAAI;YACb;;;YAEA,KAAA;mBAAA,SAAA,QAAQ,IAA8B;gBACpC,IAAI,CAAC,MAAM,CAAC,IAAI,GAAG;gBACnB,OAAO,IAAI;YACb;;;YAEA,KAAA;mBAAA,SAAA,cAAc,UAAkB;gBAC9B,IAAI,CAAC,MAAM,CAAC,UAAU,GAAG;gBACzB,OAAO,IAAI;YACb;;;YAEA,KAAA;mBAAA,SAAA,cAAc,UAAkB;gBAC9B,IAAI,CAAC,MAAM,CAAC,UAAU,GAAG;gBACzB,OAAO,IAAI;YACb;;;YAEc,KAAA;mBAAd,SAAc,QAAQ,UAAkB;;uBAAxC,oBAAA;wBACQ;;wBAAA,QAAQ,AAAC,CAAA,MAAK,MAAM,CAAC,UAAU,IAAI,IAAG,IAAK,KAAK,GAAG,CAAC,GAAG;wBAC7D;;4BAAO,IAAI,QAAQ,SAAC;uCAAY,WAAW,SAAS;;;;gBACtD;;;;YAEc,KAAA;mBAAd,SAAc,cAAc,QAAkB;;uBAA9C,oBAAA;;wBACE,OAAQ,MAAK,MAAM,CAAC,YAAY;4BAC9B,KAAK;gCACH;;oCAAO,SAAS,IAAI;;4BACtB,KAAK;gCACH;;oCAAO,SAAS,IAAI;;4BACtB,KAAK;gCACH;;oCAAO,SAAS,IAAI;;wBACxB;;;;;gBACF;;;;YAEM,KAAA;mBAAN,SAAM;;uBAAN,oBAAA;wBACM,UACA,QAEC,2BAAA,mBAAA,gBAAA,WAAA,OAAM,aAIL,YAII,YACA,QAEA,SAOA,UAMF,gBAEC,4BAAA,oBAAA,iBAAA,YAAA,QAAM,cAKJ;;;;gCAlCP,WAAW;gCACX,SAAS,MAAK,kBAAkB;gCAE/B,kCAAA,2BAAA;;oCAAL,IAAK,YAAqB,MAAK,mBAAmB,uBAA7C,6BAAA,QAAA,yBAAA,iCAA+C;wCAAzC,cAAN;wCACH,SAAS,YAAY;oCACvB;;oCAFK;oCAAA;;;6CAAA,6BAAA;4CAAA;;;4CAAA;kDAAA;;;;gCAIC,aAAa,MAAK,MAAM,CAAC,UAAU,IAAI;;;qCAEtC,CAAA,YAAY,UAAS;;;;;;;;;;;;gCAElB,aAAa,IAAI;gCACjB,SAAS,WAAW,MAAM;gCAE1B,UAAuB;oCAC3B,QAAQ,OAAO,MAAM;oCACrB,SAAS,OAAO,OAAO;oCACvB,MAAM,OAAO,IAAI,GAAG,KAAK,SAAS,CAAC,OAAO,IAAI,IAAI;oCAClD,QAAA;gCACF;gCAEiB;;oCAAM,MAAM,MAAK,MAAM,CAAC,GAAG,EAAE;;;gCAAxC,WAAW;gCAEjB,IAAI,CAAC,SAAS,EAAE,EAAE;oCAChB,MAAM,IAAI,MAAM,AAAC,eAAkC,OAApB,SAAS,UAAU;gCACpD;gCAEsB;;oCAAM,MAAK,aAAa,CAAC;;;gCAA3C,iBAAkB;gCAEjB,mCAAA,4BAAA;;oCAAL,IAAK,aAAqB,MAAK,oBAAoB,uBAA9C,8BAAA,SAAA,0BAAA,kCAAgD;wCAA1C,eAAN;wCACH,iBAAiB,aAAY;oCAC/B;;oCAFK;oCAAA;;;6CAAA,8BAAA;4CAAA;;;4CAAA;kDAAA;;;;gCAIL;;;wCAAQ;wCAAM;;;;gCACP;gCACP,IAAI,YAAY,cAAc,AAAC,MAAgB,IAAI,KAAK,cAAc;oCACpE;;;4CAAQ;4CAAgB;;;gCAC1B;gCACA;gCACA;;oCAAM,MAAK,OAAO,CAAC;;;gCAAnB;;;;;;;;;;;gCAIJ;;;wCAAQ,IAAI,MAAM;wCAAkB;;;;;gBACtC;;;;WA9HI;;AAiIN,SAAS,YAAY,EAAE,aAAa,GAAkB","file":"index.js","sourcesContent":["// src/index.ts\n\ntype RequestInterceptor<T> = (config: RequestConfig<T>) => RequestConfig<T>;\ntype ResponseInterceptor<R> = (response: R) => R;\n\ninterface RequestConfig<T> {\n  url: string;\n  method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\";\n  headers?: Record<string, string>;\n  body?: T;\n  maxRetries?: number;\n  retryDelay?: number;\n  responseType: \"json\" | \"text\" | \"blob\";\n}\n\ninterface FetchBuilder<T> {\n  setBody(body: RequestConfig<T>[\"body\"]): this;\n  setHeaders(headers: RequestConfig<T>[\"headers\"]): this;\n  setMaxRetries(maxRetries: number): this;\n  setMethod(method: RequestConfig<T>[\"method\"]): this;\n  setMinRetries(minRetries: number): this;\n  setResponseType(responseType: RequestConfig<T>[\"responseType\"]): this;\n  setRetryDelay(retryDelay: number): this;\n  setUrl(url: string): this;\n}\n\nclass ConfigManager {\n  private static instance: ConfigManager;\n  private globalConfig: Partial<RequestConfig<any>> = {};\n\n  private constructor() {}\n\n  static getInstance(): ConfigManager {\n    if (!ConfigManager.instance) {\n      ConfigManager.instance = new ConfigManager();\n    }\n    return ConfigManager.instance;\n  }\n\n  setGlobalConfig(config: Partial<RequestConfig<any>>): void {\n    this.globalConfig = { ...this.globalConfig, ...config };\n  }\n\n  getGlobalConfig(): Partial<RequestConfig<any>> {\n    return this.globalConfig;\n  }\n\n  resetGlobalConfig() {\n    this.globalConfig = {};\n  }\n}\n\nclass FetchBuilder<T> implements FetchBuilder<T> {\n  private config: RequestConfig<T> = {\n    url: \"\",\n    method: \"GET\",\n    headers: {},\n    responseType: \"json\",\n    maxRetries: 3,\n    retryDelay: 1000,\n  };\n\n  private requestInterceptors: RequestInterceptor<T>[] = [];\n  private responseInterceptors: ResponseInterceptor<any>[] = [];\n\n  private getEffectiveConfig(): RequestConfig<T> {\n    const globalConfig = ConfigManager.getInstance().getGlobalConfig();\n    return {\n      ...globalConfig,\n      ...this.config,\n      headers: {\n        ...globalConfig?.headers,\n        ...this.config.headers,\n      } as RequestConfig<T>[\"headers\"],\n    };\n  }\n\n  addRequestInterceptor(interceptor: RequestInterceptor<T>): this {\n    this.requestInterceptors.push(interceptor);\n    return this;\n  }\n\n  addResponseInterceptor<R>(interceptor: ResponseInterceptor<R>): this {\n    this.responseInterceptors.push(interceptor);\n    return this;\n  }\n\n  setUrl(url: string): this {\n    this.config.url = url;\n    return this;\n  }\n\n  setMethod(method: RequestConfig<T>[\"method\"]): this {\n    this.config.method = method;\n    return this;\n  }\n\n  setHeaders(headers: RequestConfig<T>[\"headers\"]): this {\n    this.config.headers = headers;\n    return this;\n  }\n\n  setBody(body: RequestConfig<T>[\"body\"]): this {\n    this.config.body = body;\n    return this;\n  }\n\n  setMaxRetries(maxRetries: number): this {\n    this.config.maxRetries = maxRetries;\n    return this;\n  }\n\n  setRetryDelay(retryDelay: number): this {\n    this.config.retryDelay = retryDelay;\n    return this;\n  }\n\n  private async backoff(retryCount: number): Promise<void> {\n    const delay = (this.config.retryDelay || 1000) * Math.pow(2, retryCount);\n    return new Promise((resolve) => setTimeout(resolve, delay));\n  }\n\n  private async parseResponse(response: Response): Promise<any> {\n    switch (this.config.responseType) {\n      case \"json\":\n        return response.json();\n      case \"text\":\n        return response.text();\n      case \"blob\":\n        return response.blob();\n    }\n  }\n\n  async execute<R = any>(): Promise<[Error | null, R | null]> {\n    let attempts = 0;\n    let config = this.getEffectiveConfig();\n\n    for (const interceptor of this.requestInterceptors) {\n      config = interceptor(config);\n    }\n\n    const maxRetries = this.config.maxRetries || 0;\n\n    while (attempts <= maxRetries) {\n      try {\n        const controller = new AbortController();\n        const signal = controller.signal;\n\n        const options: RequestInit = {\n          method: config.method,\n          headers: config.headers,\n          body: config.body ? JSON.stringify(config.body) : undefined,\n          signal,\n        };\n\n        const response = await fetch(this.config.url, options);\n\n        if (!response.ok) {\n          throw new Error(`HTTP error: ${response.statusText}`);\n        }\n\n        let parsedResponse = (await this.parseResponse(response)) as R;\n\n        for (const interceptor of this.responseInterceptors) {\n          parsedResponse = interceptor(parsedResponse);\n        }\n\n        return [null, parsedResponse];\n      } catch (error) {\n        if (attempts >= maxRetries || (error as Error).name === \"AbortError\") {\n          return [error as Error, null];\n        }\n        attempts++;\n        await this.backoff(attempts);\n      }\n    }\n\n    return [new Error(\"Unknown error\"), null];\n  }\n}\n\nexport { FetchBuilder, ConfigManager, RequestConfig };\n"]}